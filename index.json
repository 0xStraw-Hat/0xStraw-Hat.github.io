[{"categories":["Notes"],"content":"\rDescription\rThis writeup focuses on glibc\u0026rsquo;s positional-parameter ($) handling in vfprintf: how detecting $ forces an immediate switch from the fast parser to printf_positional. It explains the two-phase positional engine‚Äîfirst parsing all specifiers, then freezing argument values by replaying a saved va_list into args_value[]‚Äîand how every later conversion (e.g. %c) is served from that array.\nIntroduction\rFormat string vulnerabilities are among the most subtle and powerful primitives in memory corruption. At first glance, they look simple: control the format string, leak some pointers with %p, maybe write something with %n, and move on.\nBut once you start digging deeper especially into glibc\u0026rsquo;s internals, you realize that not all format strings behave the same.\nLet\u0026rsquo;s quickly recap the basics.\nA Quick Refresher\nWhen dealing with a format string vulnerability, two specifiers dominate exploitation:\n%p ‚Äî used to leak stack values (usually pointers). %n ‚Äî used to write the number of printed bytes to an address. for example: printf(\u0026#34;%p %p %p\u0026#34;); This prints consecutive values pulled from the stack.\nIf we want to access a specific stack index directly, we can use the positional parameter syntax with $:\nprintf(\u0026#34;%25$p\u0026#34;); This tells printf:\n\u0026ldquo;Don\u0026rsquo;t consume arguments sequentially, give me the 25th argument.\u0026rdquo;\nSimilarly, we can write to a specific stack argument:\nprintf(\u0026#34;%7$n\u0026#34;); Which writes to the 7th argument.\nSo far, everything seems straightforward. The $ modifier just looks like a convenient way to index arguments directly instead of walking through them one by one.\nMost tutorials stop here.\nBut this is where things start getting interesting.\nThe Assumption Most People Make\rWhen exploiting format strings, we often rely on a simple mental model:\nprintf reads arguments from the stack.\n%n modifies memory.\nAny later reads should reflect that modification.\nSo naturally, we assume something like this should work:\nprintf(\u0026#34;%n %p\u0026#34;); If %n modifies some stack value, and %p later reads it, we expect %p to print the modified value, Right?\nNow let\u0026rsquo;s make it more controlled:\nprintf(\u0026#34;%2$n %2$p\u0026#34;); We write to the second argument then immediately print it again. Logically we expect to see the updated value.\nBut sometimes‚Ä¶\nYou don\u0026rsquo;t.\nSometimes it prints the original value.\nAnd that\u0026rsquo;s where the mystery begins.\nThe Hidden Switch inside glibc\rnow lets zoom into the internals.\nAt this point we\u0026rsquo;ve seen something very very strange:\nusing $ sometimes causes printf to behave in a different way than usuall , especially when mixing %n and later reads of teh same argument, in fact this is not accidental it is the result of the internal design inside glibc The Entry point\rIf we examined the source code of printf.c function we will see this:\nint printf(const char *format, ...) { va_list arg; int done; va_start(arg, format); done = vprintf(format, arg); va_end(arg); return done; } you will notice that the printf uses the internal function vfprintf to parse and print the format. in fact all the printf-style functions do that not just printf.\nThis vfprintf function is responsible for:\nparsing the format string. Reading the arguments passed to printf pereforming conversions writing the final output So we will need to dive into the vfprintf itself to really understand what\u0026rsquo;s going on under the hood.\nAfter analyzing the vfprintf.c file I found out this -\u0026gt;\nThere are two different paths in the file or lets call them engines:\nFast Path \u0026amp; Positionala Path. once $ is involved, glibc switches engines and stay there for the rest of the printf call (it does not \u0026ldquo;go back\u0026rdquo; to the first engine)\nMind Map\rHere\u0026rsquo;s a draw which shows the logic.\nI just want you to remember:\nonce $ is involved, glibc switches engines and stay there for the rest of the printf call (it does not \u0026ldquo;go back\u0026rdquo; to the Fast Path)\nFast Path Vs do_Posistional Path\rNow lets dive into both of them and study what\u0026rsquo;s different about them.\nFast Path\rthe ‚Äúnormal‚Äù non-positional engine that runs when the loop didn\u0026rsquo;t encounter $ yet in the string.\nthe Function that\u0026rsquo;s responsible for this path is the Xprintf_buffer\nXprintf_buffer (struct Xprintf_buffer *buf, const CHAR_T *format, va_list ap, unsigned int mode_flags) Xprintf_buffer saves a copy of the argument cursor every itiration so it is renewable haha (in case of the fmtstring vuln this is the stack idexes)\nIt scans the format string until the next % (__find_specmb/__find_specwc), writes the literal text before it, then starts parsing right after %.\nIt parses one specifier at a time:\nreads the next character after % if it‚Äôs width/precision (123, *, .) it sets width/prec if it‚Äôs a length modifier (h, hh, l, ll, z, t, j, L, w...) it sets type flags and continues when it finally hits the conversion letter (d, x, s, p, c, n, %, etc.), it immediately consumes the matching argument from va_list with va_arg(ap, ...) and prints it. imagine va_list like an array that holds a copy of the printf arguments (in case of the format string vulnerabilty imagine it like the stack idexes)\nin every int\nAfter finishing that one specifier it advances and finds the next %, and do the same checks again.\nNow once the Loop encounters a $ (positional parameters) it will switch to the do_positional engine or path.\nif (pos \u0026amp;\u0026amp; *tmp == L_(\u0026#39;$\u0026#39;)){ goto do_positional; } do_positional path\rNow its time for the do_positional era haha:\ndo_positional: printf_positional (buf, format, readonly_format, ap, \u0026amp;ap_save,nspecs_done, lead_str_end, work_buffer, save_errno, grouping, thousands_sep, mode_flags); OKay first lets talk about `specs[]` array. Its just an array of parsed format specifier descriptions. In printf_positional, glibc can‚Äôt format immediately (because `%2$d` means ‚Äúuse arg #2‚Äù), so it first builds a list: Each `specs[i]` corresponds to one`%...` in the format string, and it stores things like: - `specs[i].info.spec` -\u0026gt; the conversion letter (d, c, s, n, p, ...) - `specs[i].info.width/prec` -\u0026gt; width/precision - `specs[i].next_fmt` -\u0026gt; pointer to where the next `%` starts in the format string - `specs[i].end_of_fmt` -\u0026gt; pointer to where this specifier ends so it can printf the literal text after it those are not all of them but the most important things that specs array stores So ‚Äúparsing specs‚Äù means: calling` __parse_one_specmb/__parse_one_specwc`, to fill `specs[i]` for each `%...` so later code can say ‚Äúokay, spec 0 is `%2$c`, spec 1 is `%1$d`. Now moving back to the execution flow of the do_positional engine.\nI will devide it into 4 phases.\nPhase one\rIn this phase it will iterate over the rest of the string and stores it in the specs array like mentioned above. for (const UCHAR_T *f = lead_str_end; *f != L_(\u0026#39;\\0\u0026#39;); f = specs[nspecs++].next_fmt) { if (nspecs == specs_limit) { if (!scratch_buffer_grow_preserve (\u0026amp;specsbuf)) { Xprintf_buffer_mark_failed (buf); goto all_done; } specs = specsbuf.data; specs_limit = specsbuf.length / sizeof (specs[0]); } /* Parse the format specifier. */ bool failed; #ifdef COMPILE_WPRINTF nargs += __parse_one_specwc (f, nargs, \u0026amp;specs[nspecs], \u0026amp;max_ref_arg, \u0026amp;failed); #else nargs += __parse_one_specmb (f, nargs, \u0026amp;specs[nspecs], \u0026amp;max_ref_arg, \u0026amp;failed); #endif if (failed) { Xprintf_buffer_mark_failed (buf); goto all_done; } } /* Determine the number of arguments the format string consumes. */ nargs = MAX (nargs, max_ref_arg); union printf_arg *args_value; calls __parse_one_specmb/__parse_one_specwc repeatedly. output: each specs[i] records flags,width,prec,length,spec + which arg indexes it references.\nphase two\rCompute argument types.\nfor (cnt = 0; cnt \u0026lt; nspecs; ++cnt) { /* If the width is determined by an argument this is an int. */ if (specs[cnt].width_arg != -1) args_type[specs[cnt].width_arg] = PA_INT; /* If the precision is determined by an argument this is an int. */ if (specs[cnt].prec_arg != -1) args_type[specs[cnt].prec_arg] = PA_INT; switch (specs[cnt].ndata_args) { case 0:\t/* No arguments. */ break; case 1:\t/* One argument; we already have the type and size. */ args_type[specs[cnt].data_arg] = specs[cnt].data_arg_type; args_size[specs[cnt].data_arg] = specs[cnt].size; break; default: /* We have more than one argument for this format spec. We must call the arginfo function again to determine all the types. */ (void) (*__printf_arginfo_table[specs[cnt].info.spec]) (\u0026amp;specs[cnt].info, specs[cnt].ndata_args, \u0026amp;args_type[specs[cnt].data_arg], \u0026amp;args_size[specs[cnt].data_arg]); break; } } It will build args_type[] / args_size[] so it knows how to read each argument (or the stack indexes in case of fmtstring vuln just to make it clear for u) Phase three\rThis is the devil this is the part that caused me headaches and drove me crazy while trying to know what\u0026rsquo;s the issue with my exploit.\nThis is the part that it reads alllllll the arguments values (again imagine it like the stack indexes in the fmt vuln just to make things easy) into args_value[] array and use it for the rest of the do positional loop this is the freeze part basically it takes a screenshot for the stack and store it and use it tell the end of the execution of the printf function. args_value[cnt].mem = va_arg (*ap_savep, type); here it will pull the value from the latest saved va_list and save it into args_value and then he will use args_value for the rest of the string that\u0026rsquo;s why we say it will take a screenshot of the stack\njust like in this chart\nPhase 4\rExecute each specifier in order using the frozen args.\nand after executing all the specifier vfprintf will return back up to the vfprintf caller\nTL;DR; for the pwners\rUsing `$` forces glibc to switch into positional mode, where it copies all arguments into an internal array before executing any conversions. In other words, it takes a snapshot of the argument list at the beginning of the printf call Because of this: - If you modify a stack value using %n - And you already triggered positional mode with $ - Any later specifier (like %p, %x, %c) will read from the frozen copy not from the live stack So your modification will not appear during the rest of that printf execution However if you avoid using `$` glibc stays in the fast path: - Arguments are consumed sequentially via va_arg. - Each specifier reads directly from the live argument stream. - A modification made by %n can affect later reads. So if your exploit relies on: \u0026gt; Modify ‚Üí Then reuse the modified value Do not trigger positional mode. Instead of `%7$p`, advance manually using padding like: `%c%c%c%c` so that you reach the desired argument without introducing $. show case\rfirst the fast path example #include \u0026lt;stdio.h\u0026gt; int main() { int x = 0x41414141; printf(\u0026#34;Before: x = 0x%x\\n\u0026#34;, x); printf(\u0026#34;%n\u0026#34;, \u0026amp;x); printf(\u0026#34;After: x = 0x%x\\n\u0026#34;, x); return 0; } Before: x = 0x41414141 After: x = 0x0 notice here x got modified and u printed it sucessfully\nsecond the positional path example #include \u0026lt;stdio.h\u0026gt; int main() { int x = 0x41414141; printf(\u0026#34;Before: x = 0x%x\\n\u0026#34;, x); printf(\u0026#34;During: x = %1$n 0x%2$x\\n\u0026#34;, \u0026amp;x, x); return 0; } Before: x = 0x41414141 During: x = 0x41414141 and as we expected it printed the same value not 0 That\u0026rsquo;s it we reached the end.\nIf there‚Äôs one thing you should take away from this writeup, let it be this:\nWhen exploiting a format string vulnerability if your exploit:\nmodifies a stack value using %n Then expects to use that modified value somehow later It will behave differently depending on whether $ was used.\n","date":"2026-02-21T14:23:38+02:00","permalink":"/post/vprintf/","section":"post","tags":["C","Format String"],"title":"Inside glibc vfprintf"},{"categories":null,"content":"Yo hackers! It‚Äôs 0xStrawHat again üè¥‚Äç‚ò†Ô∏è\nAn enthusiastic pwner and web hacker with a love for breaking anything that can be hacked.\nI have a deep passion for the thrill of the hunt, constantly sharpening my skills in the art of exploitation.\nPlaying CTFs is not just a hobby, it\u0026rsquo;s a lifestyle where I push my limits and learn something new every day.\nI am proud to be a pwner @0xL4ugh team, collaborating with brilliant minds to solve complex challenges.\nWhether it\u0026rsquo;s binary exploitation or web vulnerabilities, I\u0026rsquo;m always ready to dive into the code.\nWelcome to my world of security research, where every crash is an opportunity and every shell is a victory.\n","date":"2026-01-27T00:00:00Z","permalink":"/about/","section":"","tags":null,"title":"About Me"}]